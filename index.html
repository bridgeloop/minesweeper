<!DOCTYPE html>
<!--
	ISC License

	Copyright (c) 2023, aiden (aiden@cmp.bz)

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-->
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<link rel="icon" href="about:favicon">
		<title>Minesweeper</title>
		<script>var version = "0.0.4";</script>
		<style>
			@keyframes alert {
				from {
					transform: scale(0.95, 0.95);
				}
				70% {
					transform: scale(1.02, 1.02);
				}
				to {
					transform: scale(1, 1);
				}
			}
			* {
				box-sizing: border-box;
			}
			.gamemode {
				border-radius: 0.4rem;
				background: var(--settings-option-background);
			}
			.gamemode > div:nth-child(1) {
				display: flex;
			}
			.gamemode > div:nth-child(1) > div:nth-child(1) {
				flex: 1;
				padding: 0.8rem;
				border-right: solid 1px white;
			}
			.gamemode > div:nth-child(1) > div:nth-child(2) {
				flex: 1;
				padding: 0.8rem;
				border-left: solid 1px white;
			}
			.gamemode > div {
				border-bottom: solid 2px white;
			}
			.gamemode > button {
				border-radius: 0 0 0.4rem 0.4rem;
			}
			@font-face {
				font-family: "PT Sans Caption";
				font-style: normal;
				font-weight: 700;
				font-display: swap;
				src: url("./pt-sans-caption.woff2") format("woff2");
				unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
			}
			*:not(input):not(pre) {
				-webkit-user-select: none;
			}
			h1, h2, h3, h4, h5, h6, .title {
				margin: 0;
				user-select: none;
				line-height: 1;
			}
			h1 {
				font-size: 2rem;
			}
			h2 {
				font-size: 1.5rem;
			}
			h3 {
				font-size: 1.18rem;
			}
			b, button {
				font-size: 1.06rem;
				font-weight: bold;
			}
			h4 {
				font-size: 1.03rem;
			}
			h5 {
				font-size: 1rem;
			}
			h6 {
				font-size: 0.89rem;
			}
			h5 + div {
				margin-top: 4px;
			}
			htitle {
				font-size: 1.335em;
				font-weight: bolder;
			}
			html {
				height: 100%;
				width: 100%;
				-webkit-tap-highlight-color: #00000000;
				background: #000000;
			}
			body {
				margin: 0;
				padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
				overflow: hidden;
				height: 100%;
				width: 100%;
				color: white;
				font-family: "PT Sans Caption", sans-serif;
			}
			.page {
				height: 100%;
				width: 100%;
				background: var(--page-background);
				display: flex;
				flex-direction: column;
			}
			.page-bar {
				background: var(--page-bar-background);
				display: flex;
				justify-content: space-between;
				user-select: none;
				align-items: center;
			}
			.page-bar > *:last-child {
				text-align: right;
			}
			.pad {
				padding: 0.8rem;
			}
			.page-content {
				flex: 1;
				padding: 0.8rem 0.8rem 0 0.8rem;
				overflow-y: scroll;
				overflow-x: hidden;
				word-break: break-word;
			}
			.page-content::after {
				height: 0.8rem;
				content: " ";
				display: block;
			}
			button {
				border: 0;
				background: none;
				box-shadow: none;
				font-size: inherit;
				color: inherit;
				font-family: inherit;
				cursor: pointer;
				user-select: none;
				text-transform: inherit;
			}
			label {
				cursor: pointer;
			}
			.btn {
				background: var(--btn-background);
				padding: 0.8rem;
				border-radius: 0.4rem;
			}
			.settings-options {
				padding-top: 0.4rem;
				padding-bottom: 0.4rem;
				background: var(--settings-option-background);
				border-radius: 0.4rem;
			}
			.settings-option {
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 0.4rem 0.8rem;
			}
			.setting-selection {
				display: flex;
				flex: 1;
				background: #0000FF;
				text-align: center;
				align-items: center;
				max-width: max(16%, 265px);
			}
			.settings-options .settings-checkbox, .settings-options .settings-number-field, .settings-select {
				height: 1.5rem;
			}
			.settings-checkbox {
				margin-top: 0;
				margin-bottom: 0;
				margin-right: 0;
				pointer-events: none;
				user-select: none;
			}
			.settings-number-field, .settings-select {
				margin: 0 0 0 6%;
				width: 4rem;
			}
			.page-bar-buttons {
				display: flex;
				height: 100%;
				margin: 0.8rem;
				align-items: center;
				justify-content: end;
				flex-wrap: wrap;
				gap: 0.8rem;
			}
			.page-bar-buttons > button {
				text-align: right;
			}
			hr {
				border: 0;
				margin: 0;
				height: 0.8rem;
				//background: white;
			}
			#game-container {
				flex: 1;
				display: flex;
				overflow: hidden;
			}
			#game-container > canvas {
				margin: auto;
			}
			.width-100percent {
				width: 100%;
			}
			noscript {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: black;
				overflow: scroll;
			}
			#detected-js, #alert-prototype {
				display: none;
			}
			.page-bar-buttons button:not(.btn) {
				padding: 0;
				height: 100%;
			}
			.alert {
				position: fixed;
				display: flex;
				left: 0;
				top: 0;
				width: 100%;
				height: 100%;
				background: #0000006a;
				justify-content: center;
			}
			.alert > div {
				flex: 1;
				margin: auto;
				display: flex;
				justify-content: center;
				max-height: 100%;
			}
			.alert > div > div {
				width: min(70%, 30rem);
			}
			.vr {
				height: 0px;
				width: 0.8rem;
			}
		</style>
	</head>
	<body>
		<div class="page" data-page="menu" data-page-instruction="updateStats">
			<div class="page-bar">
				<div class="pad">
					<htitle>Minesweeper</htitle>
				</div>
				<div class="page-bar-buttons">
					<button data-nav="settings" translate>Settings</button>
				</div>
			</div>
			<div class="page-content">
				<div class="gamemode">
					<div>
						<div>
							<b class="title" translate>Boards Played</b>
							<h2 id="boards-played">&nbsp;</h2>
						</div>
						<div>
							<b class="title" translate>Boards Won</b>
							<h2 id="boards-won">&nbsp;</h2>
						</div>
					</div>
					<div class="settings-options" style="border-radius: 0">
						<div class="settings-option">
							<b class="title" translate>Board Width</b>
							<input type="number" value="10" class="settings-number-field" id="board-width">
						</div>
						<div class="settings-option">
							<b class="title" translate>Board Height</b>
							<input type="number" value="10" class="settings-number-field" id="board-height">
						</div>
						<div class="settings-option">
							<b class="title" translate>Suggested Amount of Bombs</b>
							<input type="number" value="12" class="settings-number-field" id="suggested-bomb-count">
						</div>
					</div>
					<button class="btn width-100percent" data-click-instruction="playGame" translate>Play</button>
				</div>
			</div>
		</div>
		<div class="page" data-page="settings" data-page-instruction="settings get, settings load">
			<div class="page-bar">
				<div class="pad">
					<htitle translate>Settings</htitle>
				</div>
				<div class="page-bar-buttons">
					<button data-click-instruction="settings apply, showMessage({ &quot;msg&quot;: &quot;Applied settings.&quot; }), settings load" translate>Apply</button>
					<button data-click-instruction="prevPage" translate>Close</button>
				</div>
			</div>
			<div class="page-content">
				<h5 translate>General</h5>
				<div class="settings-options">
					<label for="theme-select">
						<div class="settings-option">
							<b class="title" translate>Theme</b>
							<select id="theme-select" data-name="theme" class="settings-select">
								<option selected translate>Auto</option>
								<option translate>Blue</option>
								<option translate>Dark</option>
							</select>
						</div>
					</label>
					<label for="uppercase-checkbox">
						<div class="settings-option">
							<b class="title" translate>Uppercase Text</b>
							<input type="checkbox" id="uppercase-checkbox" data-name="uppercaseText" class="settings-checkbox" checked>
						</div>
					</label>
				</div>
				<hr>
				<h5 translate>Game Board</h5>
				<div class="settings-options">
					<div class="settings-option">
						<b class="title" translate>Touch Flag Delay (ms)</b>
						<input type="number" integer data-name="touchFlagDelay" min="80" max="1600" class="settings-number-field" value="500">
					</div>
				</div>
				<hr>
				<div class="gamemode">
					<div><div style="border: none"><b class="title" id="version-text"></b></div></div>
					<button class="btn width-100percent" data-click-instruction="updateAlert" translate>Check for Updates</button>
				</div>
			</div>
			</div>
		</div>
		<div class="alert" id="alert-prototype"><div><div><div class="page"><div class="page-bar"><div class="pad"><htitle></htitle></div><div class="page-bar-buttons"></div></div><div class="page-content"></div></div></div></div></div>
		<div class="page" data-page="game">
			<div class="page-bar">
				<div class="pad">
					<htitle translate>Game</htitle>
				</div>
				<div class="page-bar-buttons">
					<button data-nav="settings" translate>Settings</button>
					<button data-click-instruction="closeGame" translate>Close</button>
				</div>
			</div>
			<div id="game-container">
				<canvas id="game"></canvas>
			</div>
		</div>
		<noscript><b>JavaScript is required.</b></noscript>
		<script>
			onunhandledrejection = onerror = (msg, file, line, column, error) => {
				if (console.trace) {
					console.log = console.trace;
				}
				console.log(msg, error);
				let functionName = "onerror";
				if (typeof msg === "object") {
					file = msg.reason.fileName;
					line = msg.reason.lineNumber;
					column = msg.reason.columnNumber;
					error = msg.reason;
					msg = msg.reason.message;
					functionName = "onunhandledrejection";
				}
				document.documentElement.innerHTML = "<head><title>Minesweeper</title><style>html{background:black;color:lightgrey;}a{color:orange;}</style><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" ></head><body><pre></pre><a href>Retry</a> <a href=\"force_update.html\">Force Update</a></body>";
				let pre = document.getElementsByTagName("pre")[0];
				pre.style.width = "100%";
				pre.style.whiteSpace = "pre-wrap";
				pre.style.wordBreak = "break-word";
				//pre.style.fontFamily = "monospace";
				document.body.style.fontFamily = "monospace";
				pre.innerText = `*** ${functionName} called ***

An error (${error?.__proto__?.constructor?.name ?? "Error"}) occurred.
Description: ${(JSON.stringify(msg))}.

${navigator.userAgent}
v${version} @ ${new Date}
`;
				if (error && error.stack) {
					pre.innerText += `
${error.stack}`;
				} else {
					pre.innerText += `
${file} @ ${line}`
				}
				stop();
			}
		</script>
		<script>
			// game //
			function distinctRNG(min = 0, max = 99) {
				let ints = [];
				if (Array.isArray(min)) {
					ints = [...min];
				} else {
					for (let idx = min; idx <= max; ++idx) {
						ints.push(idx);
					}
				}
				return function generate(n = 1) {
					for (let idx1 = Math.max(0, ints.length - 1); idx1 > 0; --idx1) {
						let idx2 = Math.floor(Math.random() * ints.length);
						const x = ints[idx1];
						ints[idx1] = ints[idx2];
						ints[idx2] = x;
					}
					return ints.slice(0, n);
				}
			}
			function ctxSaver(context) {
				let properties = {};
				return {
					saveCtx: (...keys) => {
						for (let key of keys) {
							properties[key] = context[key];
						}
					},
					loadCtx: _ => {
						for (let [key, val] of Object.entries(properties)) {
							context[key] = val;
						}
					},
				}
			}
			function cnfRange(x, min, max, round = 1) {
				if (Number(x) !== x) {
					x = 1;
				}
				if (round) {
					x = Math.round(x);
				}
				if (x < min) {
					x = min;
				}
				if (x > max) {
					x = max;
				}
				return x;
			}
			function inRange(n, min, maxExclusive) {
				return n >= min && n < maxExclusive;
			}

			let canvas = document.getElementById("game");

			class Board {
				tilesAtEdges(idx) {
					return { up: idx - this.width >= 0, down: idx + this.width < this.width * this.height, left: idx % this.width != 0, right: (idx + 1) % this.width != 0, };
				}

				toggleFlag(idx) {
					if (this.generated && !this.tiles[idx].revealed) {
						this.tiles[idx].flagged = !this.tiles[idx].flagged;
					}
				}

				surroundingTiles(idx) {
					let idxs = new Set;
					let t = this.tilesAtEdges(idx);
					if (t.up) {
						idxs.add(idx - this.width);
					}
					if (t.left) {
						if (t.up) {
							idxs.add(idx - this.width - 1);
						}
						idxs.add(idx - 1);
						if (t.down) {
							idxs.add(idx + this.width - 1);
						}
					}
					if (t.down) {
						idxs.add(idx + this.width);
					}
					if (t.right) {
						idxs.add(idx + 1);
						if (t.down) {
							idxs.add(idx + this.width + 1);
						}
						if (t.up) {
							idxs.add(idx - this.width + 1);
						}
					}
					return idxs;
				}

				isFair(inputIdx) {
					// a list of revealed tiles which are currently bordering unrevealed tiles
					let toVisit = new Set([inputIdx]);
					let nodeInfo = Array.from({ length: this.tiles.length, }, (_, idx) => ({
						unrevealedSurrounding: this.surroundingTiles(idx),
						unrevealedSurroundingBombs: this.nearbyBombs(idx),
						revealed: false,
					}));

					nodeInfo[inputIdx].revealed = true;
					for (let idx of this.surroundingTiles(inputIdx)) {
						nodeInfo[idx].unrevealedSurrounding.delete(inputIdx);
					}
					let nRevealed = 1;

					let nFoundBombTiles = 0;

					let progressed;
					do {
						progressed = false;

						for (let tile of toVisit) {
							if (
								nodeInfo[tile].unrevealedSurroundingBombs === nodeInfo[tile].unrevealedSurrounding.size &&
								nodeInfo[tile].unrevealedSurroundingBombs !== 0
							) {
								progressed = true;

								// mark bombs
								if (!nodeInfo[tile].revealed) {
									throw tile + " not revealed";
								}
								toVisit.delete(tile);

								for (let bombIdx of nodeInfo[tile].unrevealedSurrounding) {
									for (let idx of this.surroundingTiles(bombIdx)) {
										nodeInfo[idx].unrevealedSurroundingBombs -= 1;
										nodeInfo[idx].unrevealedSurrounding.delete(bombIdx);
									}
									if ((nFoundBombTiles += 1) == this.bombCount) {
										return true;
									}
								}
							} else if (
								nodeInfo[tile].unrevealedSurroundingBombs === 0 &&
								nodeInfo[tile].unrevealedSurrounding.size !== 0
							) {
								progressed = true;

								// surrounding bombs are marked, reveal other surrounding tiles
								toVisit.delete(tile);
								
								for (let tileIdx of this.surroundingTiles(tile)) {
									if (this.bombs.has(tileIdx) || nodeInfo[tileIdx].revealed) {
										continue;
									}

									nodeInfo[tileIdx].revealed = true;
									if ((nRevealed += 1) == this.tiles.length - this.bombCount) {
										return true;
									}
									for (let idx of this.surroundingTiles(tileIdx)) {
										nodeInfo[idx].unrevealedSurrounding.delete(tileIdx);
									}

									toVisit.add(tileIdx);
								}
							}
						}
					} while (progressed);

					return false;
				}

				nearbyBombs(tile) {
					return [...this.surroundingTiles(tile)].filter(idx => this.bombs.has(idx)).length;
				}

				async handleClick(tile, didWin) {
					while (!this.generated) {
						if (!this.rand) {
							let arr = Object.keys(this.tiles).map(idx => Number(idx));
							let exclude = [tile, ...this.surroundingTiles(tile)].sort((a, b) => a - b);
							for (let idx = 0; idx < exclude.length; ++idx) {
								arr.splice(exclude[idx] - idx, 1);
							}
							this.rand = new distinctRNG(arr);
						}
						this.generate(tile);
						if (!this.isFair(tile)) {
							await showMessage({ msg: "Unfair board.", buttons: [
								{
									title: "Regenerate",
									function: closeAlert => {
										this.generated = false;
										closeAlert();
									},
								},
								{
									title: "Close",
								},
							]});
							this.fair = false;
						} else {
							this.fair = true;
						}
					}

					if (this.tiles[tile].flagged || this.tiles[tile].revealed) {
						return;
					}
					this.revealTiles([tile]);

					if (this.bombs.has(tile)) {
						let shouldContinue = false;
						await showMessage({ msg: "You lost!", buttons: [
							{
								title: "Continue",
								function: closeAlert => {
									shouldContinue = true;
									closeAlert();
								},
							},
							{
								title: "Close",
							}
						].slice(Number(this.fair), 2) });
						if (!shouldContinue) {
							this.revealAllTiles();
							didWin(0);
							return;
						}
						this.eliminated = true;
					}

					let revealBordering = [];
					if (this.nearbyBombs(tile) == 0) {
						revealBordering.push(tile);
					}
					while (revealBordering.length) {
						let current = revealBordering.shift();
						if (!this.bombs.has(current) && this.nearbyBombs(current) == 0) {
							revealBordering.push(...this.revealTiles(
								this.surroundingTiles(current)
							));
						}
					}

					if (this.revealedSafeTileCount == this.tiles.length - this.bombCount) {
						this.revealAllTiles();
						if (this.eliminated) {
							showMessage({ msg: "You completed the board!", });
							didWin(0);
						} else {
							showMessage({ msg: "You won!", });
							didWin(1);
						}
					}
				}
				
				constructor({ width, height, suggestedBombCount }) {
					this.width = width;
					this.height = height;
					this.suggestedBombCount = suggestedBombCount;
					this.revealedSafeTileCount = 0;
					this.generated = false;

					this.tiles = new Array(this.width * this.height);
					this.bombs = null;
					for (let idx = this.width * this.height - 1; idx >= 0; --idx) {
						this.tiles[idx] = {
							revealed: false,
							flagged: false,
						}
					}

					this.rand = null;
				}

				generate(tile) {
					this.generated = true;
					let bombTiles = this.rand(this.suggestedBombCount);
					this.bombCount = bombTiles.length;
					this.bombs = new Set(bombTiles);
				}

				revealAllTiles() {
					for (let idx in this.tiles) {
						if (!this.tiles[idx].revealed || this.tiles[idx].flagged) {
							this.tiles[idx].revealed = true;
							this.tiles[idx].flagged = false;
						}
					}
				}

				revealTiles(idxs) {
					let r = [];
					for (let idx of idxs) {
						if (idx >= 0 && idx < this.tiles.length) {
							if (!this.tiles[idx].revealed) {
								if (!this.bombs.has(idx)) {
									this.revealedSafeTileCount += 1;
									if (this.nearbyBombs(idx) == 0) {
										r.push(idx);
									}
								}
								this.tiles[idx].revealed = true;
								this.tiles[idx].flagged = false;
							}
						}
					}
					return r;
				}
			}
			class Game {
				static tileSize = 50;

				render() {
					if (!this.destroyed) {
						requestAnimationFrame(_ => this.render());
					}

					let width = Math.min(this.container.clientWidth, this.board.width * Game.tileSize);
					let height = Math.min(this.container.clientHeight, this.board.height * Game.tileSize);
					let dpr = Math.round(Math.max(devicePixelRatio, 1));
					if (width != this.width || height != this.height || dpr != this.dpr) {
						this.width = width;
						this.height = height;
						this.dpr = dpr;

						this.canvas.width = width * dpr;
						this.canvas.height = height * dpr;
						this.context.scale(dpr, dpr);
						this.canvas.style.width = width + "px";
						this.canvas.style.height = height + "px";
					}

					this.scrollLeft = Math.max(Math.min(this.scrollLeft, (this.board.width * Game.tileSize) - this.container.clientWidth), 0);
					this.scrollTop = Math.max(Math.min(this.scrollTop, (this.board.height * Game.tileSize) - this.container.clientHeight), 0);

					let scrollLeft = Math.round(this.scrollLeft);
					let scrollTop = Math.round(this.scrollTop);

					if (!this.board.generated) {
						return;
					}
					
					let rX = Math.min(this.container.clientWidth, this.board.width * Game.tileSize);
					let rY = Math.min(this.container.clientHeight, this.board.height * Game.tileSize);

					let { saveCtx, loadCtx } = new ctxSaver(this.context);
					saveCtx("fillStyle", "textBaseline", "textAlign", "font");
					this.context.textBaseline = "middle";
					this.context.textAlign = "center";
					this.context.font = Math.floor(Game.tileSize / 2) + "px monospace";

					let x = scrollLeft;
					x -= (x % Game.tileSize);

					let _y = scrollTop;
					_y -= (_y % Game.tileSize);
					
					while (x < rX + scrollLeft) {
						let y = _y;
						while (y < rY + scrollTop) {
							let boardY = Math.floor(y / Game.tileSize);
							let boardX = Math.floor(x / Game.tileSize);
							let tile = (boardY * this.board.width) + boardX;

							let renderX = x - scrollLeft;
							let renderY = y - scrollTop;
							
							let tileData = this.board.tiles[tile];
							this.context.fillStyle = "#000000";
							if (tileData.flagged) {
								this.context.fillStyle = "#0000FF";
							} else if (!tileData.revealed) {
								this.context.fillStyle = "#999999";
							} else if (this.board.bombs.has(tile)) {
								this.context.fillStyle = "#FF0000";
							}
							this.context.fillRect(renderX, renderY, Game.tileSize, Game.tileSize);
							if (this.context.fillStyle == "#000000") {
								this.context.fillStyle = "#FFFFFF";
								let bordering = this.board.nearbyBombs(tile);
								if (bordering != 0) {
									this.context.fillText(bordering, renderX + Math.ceil(Game.tileSize / 2), renderY + Math.floor(Game.tileSize / 2) + 4);
								}
							}
							y += Game.tileSize;
						}
						x += Game.tileSize;
					}

					if (this.touchInfo && !this.touchInfo.move) {
						this.context.beginPath();
						let { x, y } = this.canvasCoordinates(this.touchInfo.x, this.touchInfo.y);
						x -= this.scrollLeft;
						y -= this.scrollTop;
						this.context.arc(x, y, 25, 0, 2 * Math.PI, false);
						this.context.fillStyle = "#FFFFFF39";
						this.context.fill();
					}
					loadCtx();
				}

				addEventListeners(target, ...list) {
					for (let [name, func] of list) {
						this.events.push([target, name, func]);
						target.addEventListener(name, func);
					}
				}

				destructor() {
					for (let [target, name, func] of this.events) {
						target.removeEventListener(name, func);
					}

					this.destroyed = true;
				}
				constructor(container, canvas, gameSettings = { }, board) {
					this.destroyed = false;

					this.width = null;
					this.height = null;
					this.dpr = null;

					this.mousedownInfo = this.touchInfo = null;

					this.events = [];

					this.scrollLeft = 0;
					this.scrollTop = 0;

					this.container = container;
					this.canvas = canvas;
					this.context = canvas.getContext("2d");

					this.handleLose = gameSettings.handleLose || (_ => _);
					this.handleWin = gameSettings.handleWin || (_ => _);

					this.board = board;

					canvas.style.background = "#999999";
					canvas.style.userSelect = "none";
					canvas.style.webkitUserSelect = "none";

					this.addEventListeners(canvas,
						["contextmenu", event => event.preventDefault()],
						["touchstart", event => this.touchstart(event)],
						["touchend", event => this.touchend(event)],
						["touchmove", event => this.touchmove(event)],
						["touchcancel", event => this.touchcancel(event)],
						["mousedown", event => this.mousedown(event)],
						["mousemove", event => this.mousemove(event)],
						["mouseup", event => this.mouseup(event)],

						["wheel", event => {
							event.preventDefault();
							this.scrollLeft += event.deltaX;
							this.scrollTop += event.deltaY;
						}]
					);

					this.addEventListeners(window, ["resize", _ => this.touchcancel()]);

					this.render();
				}

				canvasCoordinates(x, y) {
					let rect = this.canvas.getBoundingClientRect();
					return { x: x - rect.left + this.scrollLeft, y: y - rect.top + this.scrollTop, };
				}
				tileForCoordinates(x, y) {
					if (y === undefined) {
						y = x.y;
						x = x.x;
					}
					return (this.board.width * Math.floor(y / Game.tileSize)) + Math.floor(x / Game.tileSize);
				}

				async click(tile) {
					await this.board.handleClick(tile, result => {
						this.paused = true;
						this[result == 0 ? "handleLose" : "handleWin"]();
					});
				}

				mousedown(event) {
					event.preventDefault();
					if (this.mousedownInfo) {
						return;
					}

					let { x, y } = event;
					let tile = this.tileForCoordinates(this.canvasCoordinates(event.x, event.y));
					this.mousedownInfo = {
						x, y, tile,
						which: event.which == 1 && !event.altKey ? 1 : 2,
						flag: event.ctrlKey || event.metaKey || event.shiftKey,
					};
				}
				mousemove(event) {
					event.preventDefault();
					if (!this.mousedownInfo) {
						return;
					}
					
					if (this.mousedownInfo.which == 2) {
						this.scrollLeft += this.mousedownInfo.x - event.x;
						this.scrollTop += this.mousedownInfo.y - event.y;

						this.mousedownInfo.x = event.x;
						this.mousedownInfo.y = event.y;
					}
				}
				async mouseup(event) {
					event.preventDefault();
					if (!this.mousedownInfo) {
						return;
					}
					
					if (!this.paused && this.mousedownInfo.which == 1) {
						let tile = this.tileForCoordinates(this.canvasCoordinates(event.x, event.y));
						if (tile == this.mousedownInfo.tile) {
							if (this.mousedownInfo.flag) {
								this.board.toggleFlag(tile);
							} else {
								await this.click(tile);
							}
						}
					}

					this.mousedownInfo = null;
				}

				touchstart(event) {
					event.preventDefault();
					if (this.touchInfo) {
						return;
					}

					let touch = event.touches[0];
					let [x, y] = [touch.clientX, touch.clientY];
					
					let tile = this.tileForCoordinates(this.canvasCoordinates(x, y));
					this.touchInfo = {
						x, y, tile,
						identifier: touch.identifier,
						flag: this.paused ? null : setTimeout(_ => {
							this.board.toggleFlag(tile);
							this.touchInfo = null;
						}, this.touchFlagDelay),
						move: this.paused,
						prev: { x, y, },
					};
				}
				touchmove(event) {
					event.preventDefault();
					if (!this.touchInfo) {
						return;
					}

					let touch = Array.prototype.find.call(
						event.changedTouches,
						touch => touch.identifier === this.touchInfo.identifier
					);
					if (!touch) {
						return;
					}

					let [x, y] = [touch.clientX, touch.clientY];
					if (
						!this.touchInfo.move &&
						Math.abs(this.touchInfo.x - x) + Math.abs(this.touchInfo.y - y) > 25
					) {
						clearTimeout(this.touchInfo.flag);
						this.touchInfo.flag = null;
						this.touchInfo.move = true;
						
						let radius = Math.max(Game.tileSize / 2);
						let angle = Math.atan2(y - this.touchInfo.y, x - this.touchInfo.x);
						this.touchInfo.prev = {
							x: this.touchInfo.x + radius * Math.cos(angle),
							y: this.touchInfo.y + radius * Math.sin(angle),
						};
					}

					if (this.touchInfo.move) {
						this.scrollLeft += this.touchInfo.prev.x - x;
						this.scrollTop += this.touchInfo.prev.y - y;

						this.touchInfo.prev = { x, y, };
					}
				}
				async touchend(event) {
					event.preventDefault();
					if (!this.touchInfo) {
						return;
					}

					let touch = Array.prototype.find.call(
						event.changedTouches,
						touch => touch.identifier === this.touchInfo.identifier
					);
					if (!touch) {
						return;
					}

					clearTimeout(this.touchInfo.flag);
					if (!this.touchInfo.move) {
						if (this.paused) { alert("???"); }
						await this.click(this.touchInfo.tile);
					}
					this.touchInfo = null;
				}
				touchcancel(event) {
					if (!this.touchInfo) {
						return;
					}
					if (!event || Array.prototype.find.call(
						event.changedTouches,
						touch => touch.identifier === this.touchInfo.identifier
					)) {
						clearTimeout(this.touchInfo.flag);
						this.touchInfo = null;
					}
				}
			}

			// web app stuff //

			ontouchstart = _ => _;
			function showMessage({ title, msg, buttons, call }) {
				return new Promise(res => {
					if (!buttons) {
						buttons = [{ title: "Close", }];
					}
					let elem = document.getElementById("alert-prototype").cloneNode(true);
					let closeAlert = _ => {
						elem.remove();
						res();
					}
					elem.pageElem = elem.children[0].children[0].children[0];
					(elem.titleElement = elem.children[0].children[0].children[0].children[0].children[0].children[0]).innerText = title ?? "";
					elem.buttonsElement = elem.children[0].children[0].children[0].children[0].children[1];
					elem.buttonsElement.addButtons = buttons => {
						let btn;
						for (let description of buttons) {
							btn = document.createElement("button");
							btn.innerText = description.title;
							description.function ??= closeAlert;
							btn.onclick = description.function.bind(btn, closeAlert);
							elem.buttonsElement.append(btn);
						}
						setTimeout(_ => btn?.focus());
					}
					elem.buttonsElement.addButtons(buttons);
					(elem.textElement = elem.children[0].children[0].children[0].children[1]).innerText = msg ?? "";
					elem.id = "";
					document.body.append(elem);
					call?.(elem, closeAlert);
				});
			}
			function instructionParser(instruction, safeFunctions = ["settings.get", "settings.load", "settings.apply", "prevPage", "closeGame", "playGame", "alert", "location.reload", "updateStats", "update", "showMessage", "updateAlert"]) {
				let functions = [];
				let components = [], component = 0;
				let idx = 0;
				let args = [];
				while (instruction[idx]) {
					if (![undefined, " ", ".", ",", "("].includes(instruction[idx])) {
						components.push(instruction[idx++]);
						for (; ![undefined, " ", ".", ",", "("].includes(instruction[idx]); ++idx) {
							components[component] += instruction[idx];
						}
						component += 1;
					}
					if (instruction[idx] == "(") {
						let jsonIdx = idx;
						let inString = 0;
						while ((inString || instruction[idx] != ")") && instruction[idx]) {
							if (instruction[idx] == "\"") {
								inString ^= 1;
							} else if (inString && instruction[idx] == "\\") {
								idx += 1;
							}
							idx += 1;
						}
						if (!instruction[idx]) {
							break;
						}
						args = JSON.parse(`[${instruction.substring(jsonIdx + 1, idx++)}]`);
						while (![undefined, ","].includes(instruction[idx])) {
							idx += 1;
						}
					}
					if (instruction[idx] == "," || !instruction[idx]) {
						functions.push([components, args]);
						component = 0, components = [], args = [];
						idx += 1;
						while (instruction[idx] == " ") {
							idx += 1;
						}
						continue;
					}
					if (instruction[idx] == "." && instruction[++idx] == ".") {
						break;
					}
					while (instruction[idx] == " ") {
						idx += 1;
					}
				}
				functions = functions.map(e => {
					if (!safeFunctions.includes(e[0].join("."))) {
						throw new Error(`instructionParser: bad function (${e[0]})`);
					}
					let obj = globalThis;
					for (idx = 0; idx < e[0].length - 1; ++idx) {
						obj = obj[e[0][idx]];
					}
					return [obj[e[0][idx]].bind(obj), e[1]];
				});
				return _ => {
					for (let [fn, args] of functions) {
						fn(...args);
					}
				}
			}

			var settings = {
				settingsPage: document.querySelector("[data-page=settings]"),
				apply() {
					let populate = (obj, nodes, prop, key, checkMinAndMax) => {
						for (let node of nodes) {
							let nodeValue = checkMinAndMax ? Number(node[prop]) : node[prop];
							if (node.hasAttribute("integer")) {
								node.value = nodeValue = Math.round(nodeValue);
							}
							if (checkMinAndMax && typeof node.min != "undefined" && typeof node.max != "undefined") {
								if (nodeValue < Number(node.min)) {
									node.value = node.min;
								} else if (nodeValue > Number(node.max)) {
									node.value = node.max;
								}
								nodeValue = Number(node.value);
							}
							obj[node.dataset.name] = nodeValue;
						}
						localStorage.setItem(key, JSON.stringify(obj));
					}
					populate(this.checkboxes, this.settingsPage.getElementsByClassName("settings-checkbox"), "checked", "settings checkboxes", false);
					populate(this.dropdowns, this.settingsPage.getElementsByClassName("settings-select"), "selectedIndex", "settings dropdowns", false);
					populate(this.numberFields, this.settingsPage.getElementsByClassName("settings-number-field"), "value", "settings numberFields", true);

					if (this.checkboxes.uppercaseText) {
						document.body.style.textTransform = "uppercase";
					} else {
						document.body.style.textTransform = "";
					}
					if (this.dropdowns.theme == 0) {
						this.darkModeQuery.onchange(this.darkModeQuery);
					} else {
						this.setTheme(this.dropdowns.theme == 1 ? "blue" : "dark");
					}
				},
				setTheme(theme) {
					if (theme === "dark") {
						document.documentElement.style.setProperty("--page-background", "#444444");
						document.documentElement.style.setProperty("--page-bar-background", "#2f2f2f");
						document.documentElement.style.setProperty("--btn-background", "#303030");
						document.documentElement.style.setProperty("--settings-option-background", "#393939");
					} else if (theme === "blue") {
						document.documentElement.style.setProperty("--page-background", "#3a9ffe");
						document.documentElement.style.setProperty("--page-bar-background", "#3a7bd5");
						document.documentElement.style.setProperty("--btn-background", "#2c77fc");
						document.documentElement.style.setProperty("--settings-option-background", "#3186fe");
					}
				},
				load() {
					let conflicts = {};
					let dependencies = {};
					let populate = (objKey, key, className, prop) => {
						p: for (;;) {
							for (let name in this[objKey]) {
								try {
									let e = document.querySelector(`.${className}[data-name="${name}"]`);
									e.parentElement.style.color = "";
									if ((e[prop] = this[objKey][name])) {
										dependencies[e.id] = null;
									}
									e.style.filter = "";
									if (e.dataset.conflicts && this[objKey][name] && !conflicts[e.id]) {
										conflicts[e.id] = [];
										for (let elemId of e.dataset.conflicts.split(" ")) {
											conflicts[elemId] = [];
											conflicts[e.id].push(elemId);
										}
									}
									if (e.dataset.depends && dependencies[e.dataset.depends] !== null) {
										dependencies[e.dataset.depends] ??= [];
										dependencies[e.dataset.depends].push(e.id);
									}
								} catch (err) {
									localStorage.removeItem(key);
									this.get();
									continue p;
								}
							}
							return;
						}
					}
					populate("checkboxes", "settings checkboxes", "settings-checkbox", "checked");
					populate("dropdowns", "settings dropdowns", "settings-select", "selectedIndex");
					populate("numberFields", "settings numberFields", "settings-number-field", "value");
					for (let elem of [Object.values(conflicts), Object.values(dependencies).filter(e => e !== null)].flat(Number.MAX_SAFE_INTEGER).map(e => document.getElementById(e))) {
						elem.parentElement.style.color = "lightgrey";
						elem.style.filter = "grayscale(100%)";
					}
				},
				ready() {
					this.darkModeQuery = matchMedia("(prefers-color-scheme: dark)");
					let fn = e => {
						if (this.dropdowns.theme == 0) {
							this.setTheme(e.matches ? "dark" : "blue");
						}
					};
					fn(this.darkModeQuery);
					this.darkModeQuery.onchange = fn;
				},
				get() {
					let populate = (objName, nodes, key, value, valueProp, processValue = _ => _) => {
						if (!(this[objName] = JSON.parse(localStorage.getItem(key)))) {
							this[objName] = {};
						}
						for (let node of nodes) {
							this[objName][node.dataset.name] ??= typeof valueProp != "undefined" ? processValue(node[valueProp]) : value;
						}
					}
					populate("checkboxes", this.settingsPage.getElementsByClassName("settings-checkbox"), "settings checkboxes", false, "checked");
					populate("dropdowns", this.settingsPage.getElementsByClassName("settings-select"), "settings dropdowns", 0, "selectedIndex", Number);
					populate("numberFields", this.settingsPage.getElementsByClassName("settings-number-field"), "settings numberFields", "", "value", Number);
				},
			}
			{
				for (let elem of document.querySelectorAll("[data-click-instruction]")) (elem => {
					elem.addEventListener("click", instructionParser(elem.dataset.clickInstruction));
				})(elem);
			}
			settings.get();
			settings.ready();
			settings.apply();

			function showPage(pageName) {
				let found = false;
				for (let page of document.querySelectorAll("[data-page]")) {
					if (page.dataset.page == pageName) {
						page.style.display = "";
						if (page.dataset?.pageInstruction) {
							instructionParser(page.dataset.pageInstruction)();
						}
						showPage.pages.push(pageName);
						found = true;
					} else {
						page.style.display = "none";
					}
				}
				if (!found) {
					throw new Error(`${pageName} not found`);
				}
			}
			showPage.pages = [];
			function prevPage() {
				showPage.pages.pop();
				showPage(showPage.pages.pop());
			}
			function setGameSettings() {
				if (!Game.current) {
					return;
				}
				Game.current.touchFlagDelay = settings.numberFields.touchFlagDelay;
			}
			function closeGame() {
				prevPage();
				Game.current.paused = true;
				requestAnimationFrame(_ => requestAnimationFrame(_ => {
					Game.current.destructor();
					delete Game.current;
				}));
			}
			let stats = JSON.parse(localStorage.getItem("menu statistics") ?? `{}`);
			if (!stats.boardsPlayed) {
				stats = { boardsPlayed: 0, boardsWon: 0, };
			}
			function updateStats() {
				document.getElementById("version-text").innerText = `Version ${version}`;
				document.getElementById("boards-played").innerText = stats.boardsPlayed;
				document.getElementById("boards-won").innerText = stats.boardsWon;
			}
			for (let btn of document.querySelectorAll("[data-nav]")) (btn => {
				btn.addEventListener("click", _ => showPage(btn.dataset.nav));
			})(btn);
			showPage("menu");

			function playGame() {
				Game.current = new Game(
					document.getElementById("game-container"),
					canvas,
					{
						handleWin: _ => {
							stats.boardsWon += 1;
							localStorage.setItem("menu statistics", JSON.stringify(stats));
						},
					},
					new Board({
						width: document.getElementById("board-width").valueAsNumber,
						height: document.getElementById("board-height").valueAsNumber,
						suggestedBombCount: document.getElementById("suggested-bomb-count").valueAsNumber,
					})
				);
				stats.boardsPlayed += 1;
				localStorage.setItem("menu statistics", JSON.stringify(stats));
				showPage("game");

				setGameSettings();
			}
			navigator.serviceWorker?.register("./sw.js", { scope: "./", }).catch(_ => showMessage({ title: "Warning", msg: "Failed to register service worker." }));
			async function message(msg, handler, swr) {
				if (!message.handlers) {
					message.handlers = new Map;
					message.id = 0n;
					navigator.serviceWorker.addEventListener("message", e => {
						message.handlers.get(e.data.id)(e);
						message.handlers.delete(e.data.id);
					});
				}
				if (typeof msg != "object") {
					msg = { message: msg };
				}
				message.handlers.set(msg.id = message.id++, handler);
				(swr || await navigator.serviceWorker.ready).active.postMessage(msg);
			}
			function update({ force, call }) {
				if (force === true) {
					call(4);
					return navigator.serviceWorker.ready.then(swr => swr.update()).then(swr => message("update", _ => call(5), swr));
				}
				fetch("./version").then(response => {
					if (response.status !== 200) {
						throw "Error getting latest version.";
					}
					return response.text();
				}).then(text => call(text.trim() > version ? 2 : 3)).catch(e => {
					call(1);
				});
			}
			function updateAlert(elem, closeAlert) {
				if (!elem) {
					return showMessage({ title: "Update Minesweeper", msg: "Checking for updates...", buttons: [], call: updateAlert, });
				}
				elem.style.zIndex = "1";
				function updateCall(id) {
					if (id === 1) {
						elem.textElement.innerText = "Connect to the Internet.";
						elem.buttonsElement.addButtons([{ title: "Close", }]);
					} else if (id === 2) {
						elem.textElement.innerText = "An update is available!";
						elem.buttonsElement.addButtons([{ title: "Update", function: _ => update({ force: true, call: updateCall, }), }, { title: "Close", }]);
					} else if (id === 3) {
						elem.textElement.innerText = "You are already using the latest Minesweeper client.";
						elem.buttonsElement.addButtons([{ title: "Force Update", function: _ => update({ force: true, call: updateCall, }), }, { title: "Close", }]);
					} else if (id === 4) {
						elem.textElement.innerText = "Updating!";
						elem.buttonsElement.innerHTML = ``;
					} else if (id === 5) {
						elem.pageElem.style.minHeight = getComputedStyle(elem.pageElem).height;
						elem.textElement.innerText = "Updated!";
						elem.style.zIndex = "";
						let animToFunc = _ => {
							elem.pageElem.parentElement.style.width = "100%";
							elem.pageElem.parentElement.parentElement.style.margin = "0px 0px";
							elem.buttonsElement.addButtons([{ title: "Close", function: location.reload.bind(location), }]);
						}
						elem.pageElem.parentElement.parentElement.style.margin = getComputedStyle(elem.pageElem.parentElement.parentElement).marginTop + " 0px";
						requestAnimationFrame(_ => {
							elem.pageElem.parentElement.parentElement.style.transition = "0.32s";
							elem.pageElem.parentElement.style.transition = "0.32s";
							requestAnimationFrame(animToFunc);
						});
					}
				}
				update({ call: updateCall, });
			}
		</script>
	</body>
</html>
